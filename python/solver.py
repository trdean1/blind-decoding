#!/usr/bin/env python
import numpy as np
import scipy
from scipy import linalg, matrix
import sys
import pickle
import copy
import select
import FlexTab
import Xmats
import dynamic

# Constants and principal functions.{{{
def equal_atm(A, B, zthresh = 1e-5): # {{{
    '''
    Determine if matrices A and B are equal up to an ATM.
    '''
    if A.shape != B.shape:
        return False

    used_rows = [False for i in range(B.shape[0])]
    for i in range(A.shape[0]):
        matched = False
        for k in range(len(used_rows)):
            if used_rows[k]:
                continue
            if np.max(np.abs(A[i] - B[k])) < zthresh \
                    or np.max(np.abs(A[i] + B[k])) < zthresh:
                matched = True
                used_rows[k] = True
        #end for
        if not matched:
            return False
    #end for

    return True
#end def # }}}
def mtx2hash(X): # {{{
    '''
    Create a python hashable string representation of a matrix.
    '''
    s = ''
    for i in range(X.shape[0]):
        for j in range(X.shape[1]):
            s += '1' if X[i, j] == 1 else '0'
        # end for
    # end for

    return s
# end def}}}
def hash2mtx(s, n): # {{{
    '''
    Create a matrix from a given hash.
    '''
    ncols = len(s) / n
    X = np.zeros((n, ncols))
    for i in range(n):
        for j in range(ncols):
            if s[i*n + j] == '1':
                X[i, j] = 1
            else:
                X[i, j] = -1
            # end if
        # end for
    # end for

    return X
# end def}}}
# End constants and principal functions.}}}

def gen_trial(X, verbose = False): #{{{
    '''
    Run the algorithm to find a nonsingular vertex of the feasible region.  In
    the current setup, the original transmitted symbol values X are selected
    such that all nonsingular vertices are both optima of the program and
    furthermore solutions to the blind decoding problem.

    Input:  X = matrix of transmitted symbols.
    Output: UY = Estimate of X using U generated by initial BFS finder.
            U = Estimate of A^-1 generated by initial BFS finder.
            Y = Matrix of received symbols.
            A = Ground truth channel gain matrix.
            Ui = Initial random feasible point.
    '''
    # Randomized n x n channel gain matrix.
    n = X.shape[0]
    A = np.random.randn(n, n)
    if verbose:
        print "A = \n%s\n" %(A)
    # Compute the received symbols Y, with no error.
    Y = A * X

    # Pick a random feasible point.
    Ui = dynamic.rand_init(n, Y)
    # Find a nonsingular vertex of the feasible region.
    U = dynamic.dynamic_solve(Ui, Y, verbose)

    # Calculate number of good cols of U * Y.
    # TODO: This is no longer necessary: done in FlexTab.
    UY = U * Y

    if verbose:
        print UY

    # Return the estimate of the symbols X, since U * Y = A^-1 * A * X = X.
    return UY, U, Y, A, Ui
#end }}}
# end function set}}}

# single specific trial functions{{{
def single_run(n, k, verbose = False, errfile = None, trap = False): # {{{
    '''
    Run a single trial, selecting one matrix from Xmats at random, filling in
    the specified number of extra columns with iid \pm 1 entries.
    Xmats should be an array where each element is itself an array of 2
    elements:
        1. A base np.matrix
        2. An integer representing the number of extra columns to add to the
        base matrix, which will be iid \pm 1
    '''
    while True:
        X = Xmats.X_guarantee(n, k)

        UY, U, Y, A, Ui = gen_trial(X)
        t = FlexTab.FlexTab(U, Y, verbose)
        if t.num_good_cols() < X.shape[0] + 1:
            continue

        try:
            t.solve()
        except Exception as e:
            if type(e) == ValueError and t.num_indep_cols() < t.n:
                print "EXCEPTION: %s: %s" %(e.message, e)
            continue

        # XXX: Deal specifically with trap instances.
        if trap:
            if not equal_atm(t.U, np.linalg.inv(A)) and t.is_trapped():
                return X, A, Y, Ui, U, t.U
            else:
                return None
        else:
            break # XXX: Clean this up a little.
    # end while

    # XXX: Refactor
    #print "COLS: good = %d, bad = %d, indep = %d" %(X.shape[1] - num_bad_cols,
    #        num_bad_cols, t.num_indep_cols())
    
    if equal_atm(t.U, np.linalg.inv(A)):
        print "EQUAL ATM"
        return 'EQATM'
    else:
        print "UNEQUAL"
        print "U =\n%s\nA^-1 =\n%s\n" %(t.U, np.linalg.inv(A))
        print "Y =\n%s" %(t.Y)
        print "U * Y = \n%s\n" %(np.round(t.U * Y))
        if np.max(np.abs(np.abs(t.U * Y) - 1)) < 1e-9:
            print "UYPM1"
            return 'UYPM1'
        if t.is_certain_max_5():
            print "UMAX"
            return 'UMAX'
        if t.is_trapped():
            print "TRAPPED"
            return 'TRAPPED'
        
        # This is an error, print some basics, save if specified.
        print "U = \n%s\nY = \n%s\nUi = \n%s\n" %(U, Y, Ui)
        if errfile is not None:
            with open(errfile, "w") as fp:
                pickler = pickle.Pickler(fp)
                pickler.dump([U, Y])
        # end if
        return 'ERROR'
# end def}}}

def repeat_run(X, A, Y, verbose = False, max_attempts = 100): # {{{
    attempts = 0
    while True:
        if attempts > max_attempts:
            return 'RUNOUT'
        attempts += 1

        # Obtain a new random feasible point.
        Ui = dynamic.rand_init(X.shape[0], Y)
        # Find a nonsingular vertex of the feasible region.
        U = dynamic.dynamic_solve(Ui, Y, verbose)
        t = FlexTab.FlexTab(U, Y, verbose)
        if t.num_good_cols() < X.shape[0] + 1: #XXX: Require +1
            continue
        try:
            t.solve()
        except Exception as e:
            if type(e) == ValueError and t.num_indep_cols() < t.n:
                print "EXCEPTION: %s: %s" %(e.message, e)
            continue
        break
    # end while

    if equal_atm(t.U, np.linalg.inv(A)) \
            or np.max(np.abs(np.abs(t.U * Y) - 1)) < 1e-9 \
            or t.n == 5 and t.is_certain_max_5():
        return 'SOLVED'
    elif t.is_trapped():
        return 'TRAPPED'
    else:
        return 'ERROR'
# end}}}

def flex_run(X, num_bad, verbose = False): # {{{
    '''
    Perform a single run of matrix X, requiring the number of bad columns
    returned by the initial BFS finder to be +num_bad+.
    Return True if we get an ATM.

    NOTE: Returns False anytime we do not get an ATM, even if we get a global
    optimum or some other potentially acceptable result.
    '''
    while True:
        UY, U, Y, A, Ui = gen_trial(X)
        t = FlexTab.FlexTab(U, Y)
        num_bad_cols = X.shape[1] - t.num_good_cols()
        if num_bad_cols == num_bad:
            break
    # end while

    t.solve()

    print "A^-1 = \n%s\n" %(np.linalg.inv(A))
    if equal_atm(t.U, np.linalg.inv(A)):
        print "EQUAL ATM"
        return True
    else:
        print "UNEQUAL"
        return False
    # end if
# end def}}}

